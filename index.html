---
title: ホーム
---

<div class="index">
  Our seriously shitty cognitive functions feel that when a large number of
  letters are there, somehow even the information is there, and they find value
  in it on their own. That's why designers in the world go to the trouble of
  writing in English what they wrote in Japanese, or suddenly start using
  French, or Chinese, Korean, or even Cyrillic as meaningless motifs. Well,
  actually, we think, "What a cool !!!!!!" with that. We think, "What a cool ".
  Even if there is not a single byte of information there. I've been
  disappointed many times when I read it and find it doesn't make any sense at
  all. I think that's good. I think that's good. Because we can't help it, we
  have an illusion of value. When you get right down to it, architectural styles
  (Art Nouveau, Rococo, Gothic, etc.) are completely an extension of such
  things. It's just decoration! That's fine, but, hey, if you're going to put
  some kind of text there, you might as well do something about it. I know it's
  your job, but ...... something, it's sad. I think it's sad, I don't know.
  ......
</div>

<script>
  class AutoScroller {
    constructor(options = {}) {
      this.options = {
        speed: 0.25,                    // ピクセル/フレーム
        pauseDuration: 500,           // 手動スクロール後の待機時間（ミリ秒）
        stopAtBottom: true,            // 最下部で停止するか
        ...options
      };

      this.isScrolling = true;
      this.pauseTimer = null;
      this.lastScrollY = window.scrollY;
      this.targetScrollY = window.scrollY;  // 目標スクロール位置

      this.init();
    }

    init() {
      this.setupEventListeners();
      this.startAnimation();
    }

    setupEventListeners() {
      // マウスホイール
      window.addEventListener('wheel', () => this.handleUserScroll(), { passive: true });

      // タッチスクロール
      let touchStartY = 0;
      window.addEventListener('touchstart', (e) => {
        touchStartY = e.touches[0].clientY;
      }, { passive: true });

      window.addEventListener('touchmove', (e) => {
        const touchY = e.touches[0].clientY;
        if (Math.abs(touchY - touchStartY) > 10) {
          this.handleUserScroll();
        }
      }, { passive: true });

      // キーボード操作
      window.addEventListener('keydown', (e) => {
        const scrollKeys = ['ArrowUp', 'ArrowDown', 'PageUp', 'PageDown', 'Home', 'End', ' '];
        if (scrollKeys.includes(e.key)) {
          this.handleUserScroll();
        }
      });
    }

    handleUserScroll() {
      this.isScrolling = false;
      this.targetScrollY = window.scrollY;  // 現在位置を目標位置に

      clearTimeout(this.pauseTimer);
      this.pauseTimer = setTimeout(() => {
        this.isScrolling = true;
      }, this.options.pauseDuration);
    }

    startAnimation() {
      const animate = () => {
        if (this.isScrolling) {
          // 目標位置を更新
          this.targetScrollY += this.options.speed;

          const maxScroll = document.documentElement.scrollHeight - window.innerHeight;

          if (this.options.stopAtBottom && this.targetScrollY >= maxScroll) {
            window.scrollTo(0, maxScroll);
            this.isScrolling = false;
          } else {
            // 毎フレーム、目標位置にスクロール
            window.scrollTo(0, this.targetScrollY);
          }

          this.lastScrollY = window.scrollY;
        } else {
          // 停止中は現在位置を目標位置に同期
          this.targetScrollY = window.scrollY;
        }

        requestAnimationFrame(animate);
      };

      requestAnimationFrame(animate);
    }
  }

  // 自動スクローラーの初期化
  document.addEventListener('DOMContentLoaded', () => {
    new AutoScroller({
      speed: 0.25,
      pauseDuration: 500,
      stopAtBottom: true
    });
  });
</script>

<!-- 
<h1>トップページに何を書くかは、後で考える</h1>
ちかいうちにメディアクエリを学び、スマホに対応させなきゃならん
どこではどういう事ができるよって説明する 短く、シンプルに -->